<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alta Pro - Bank Grade Editor</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <style>
    /* --- CSS VARIABLES & THEME --- */
    :root {
      --bg-app: #f1f5f9;       /* Light Grey App Background */
      --bg-panel: #ffffff;     /* White Toolbar */
      --accent: #cceeff;       /* YOUR COLOR: Light Blue */
      --accent-dark: #99d1f2;  /* Slightly darker blue for borders */
      --accent-active: #0066cc;/* Adobe Blue for active text/icons */
      --text: #334155;
      --border: #cbd5e1;
    }

    * { box-sizing: border-box; user-select: none; }
    
    body {
      margin: 0; font-family: 'Inter', sans-serif;
      background: var(--bg-app); color: var(--text);
      height: 100vh; display: flex; flex-direction: column; overflow: hidden;
    }

    /* --- RIBBON TOOLBAR STYLING --- */
    .ribbon {
      background: var(--bg-panel); 
      border-bottom: 1px solid var(--border);
      height: 100px; /* Tall ribbon style like PDF Gear */
      display: flex; 
      align-items: stretch; 
      padding: 0 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      z-index: 50;
      gap: 4px;
    }

    .brand-section {
      display: flex; flex-direction: column; justify-content: center;
      padding-right: 16px; margin-right: 8px;
      border-right: 1px solid var(--border);
      color: #0f172a; font-weight: 800; font-size: 18px; letter-spacing: -0.5px;
    }

    /* Tool Groups (File, Edit, etc) */
    .tool-group {
      display: flex; align-items: center; gap: 4px; padding: 6px 4px;
      position: relative;
    }
    .tool-group::after {
      content: ''; position: absolute; right: 0; top: 15px; bottom: 15px;
      width: 1px; background: var(--border);
    }
    .tool-group:last-child::after { display: none; }

    /* Big Buttons (Open, Save, Text, etc) */
    .btn-large {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100%; min-width: 55px; padding: 0 8px;
      background: transparent; border: 1px solid transparent; border-radius: 6px;
      color: #64748b; cursor: pointer; transition: all 0.1s;
      gap: 6px;
    }
    .btn-large i { font-size: 20px; margin-bottom: 2px; }
    .btn-large span { font-size: 11px; font-weight: 600; }
    
    .btn-large:hover { background: #f8fafc; color: var(--accent-active); }
    .btn-large.active { 
      background: var(--accent); 
      border-color: var(--accent-dark); 
      color: var(--accent-active); 
    }
    .btn-large:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Mini Action Column (Undo/Redo, Align) */
    .action-col {
      display: flex; flex-direction: column; justify-content: center; gap: 4px; height: 100%;
    }
    .action-row { display: flex; gap: 2px; }

    .btn-icon {
      width: 28px; height: 28px;
      border: 1px solid transparent; background: transparent; border-radius: 4px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; color: #475569;
    }
    .btn-icon:hover { background: #f1f5f9; border-color: var(--border); }
    .btn-icon.active { background: var(--accent); border-color: var(--accent-dark); color: var(--accent-active); }
    .btn-icon i { font-size: 13px; }

    /* Inputs */
    select, input[type=number] {
      height: 28px; border: 1px solid var(--border); border-radius: 4px;
      font-size: 12px; padding-left: 6px; color: #334155;
    }
    select { width: 130px; }
    input[type=number] { width: 50px; }
    input[type=color] {
      width: 28px; height: 28px; padding: 0; border: none; cursor: pointer;
    }

    /* --- CANVAS WORKSPACE --- */
    #workspace {
      flex: 1;
      background: #475569; /* Dark Grey like Adobe/PDFGear */
      overflow: auto;
      display: flex; justify-content: center;
      padding: 40px;
      position: relative;
    }

    #canvas-container {
      position: relative;
      background: white;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 8px 10px -6px rgba(0, 0, 0, 0.5);
      /* Size set by JS */
    }

    canvas { position: absolute; top: 0; left: 0; }
    #pdf-layer { z-index: 1; }
    #ui-layer { z-index: 10; cursor: crosshair; }

    /* EDITING TEXTAREA (Adobe Logic) */
    #inline-editor {
      position: absolute; z-index: 100;
      background: transparent;
      padding: 0; margin: 0;
      border: 1px dashed #0066cc; 
      outline: none;
      resize: none; 
      overflow: hidden; 
      white-space: pre;
      line-height: 1.15;
      display: none; 
      transform-origin: top left;
    }

    /* DRAG & DROP OVERLAY */
    #upload-overlay {
      position: fixed; inset: 0; z-index: 999;
      background: rgba(255,255,255,0.95);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 16px;
    }
    #upload-overlay.hidden { display: none; }
    
    .big-upload-btn {
      padding: 16px 32px; font-size: 16px; font-weight: 700;
      color: var(--accent-active); background: var(--accent);
      border: 2px solid var(--accent-dark); border-radius: 8px;
      cursor: pointer; transition: transform 0.1s;
    }
    .big-upload-btn:hover { transform: scale(1.02); }

  </style>
</head>
<body>

  <div class="ribbon">
    <div class="brand-section">
      <i class="fa-solid fa-layer-group" style="color:var(--accent-active); margin-bottom:4px;"></i>
      ALTA
    </div>

    <div class="tool-group">
      <button class="btn-large" id="btn-open">
        <i class="fa-regular fa-folder-open"></i><span>Open</span>
      </button>
      <button class="btn-large" id="btn-save" disabled>
        <i class="fa-regular fa-floppy-disk"></i><span>Save</span>
      </button>
    </div>

    <div class="tool-group">
      <div class="action-col">
        <div class="action-row">
          <button class="btn-icon" id="btn-undo" title="Undo"><i class="fa-solid fa-rotate-left"></i></button>
          <button class="btn-icon" id="btn-redo" title="Redo"><i class="fa-solid fa-rotate-right"></i></button>
        </div>
        <div class="action-row">
          <button class="btn-icon" id="btn-delete" title="Delete"><i class="fa-solid fa-trash" style="color:#ef4444;"></i></button>
        </div>
      </div>
    </div>

    <div class="tool-group">
      <button class="btn-large active" data-tool="select" id="tool-select">
        <i class="fa-solid fa-arrow-pointer"></i><span>Select</span>
      </button>
      <button class="btn-large" data-tool="text" id="tool-text">
        <i class="fa-solid fa-font"></i><span>Text</span>
      </button>
      <button class="btn-large" data-tool="whiteout">
        <i class="fa-solid fa-eraser"></i><span>Erase</span>
      </button>
      <button class="btn-large" data-tool="image" id="tool-img-trigger">
        <i class="fa-regular fa-image"></i><span>Image</span>
      </button>
    </div>

    <div class="tool-group">
      <div class="action-col">
        <div class="action-row">
          <select id="font-family">
            <option value="BankCourier">Bank Courier</option>
            <option value="Helvetica">Helvetica</option>
            <option value="Times">Times Roman</option>
          </select>
          <input type="number" id="font-size" value="12" min="6" max="96">
        </div>
        <div class="action-row">
          <button class="btn-icon" id="btn-bold" title="Bold / Darken"><i class="fa-solid fa-bold"></i></button>
          <input type="color" id="font-color" value="#000000">
          
          <div style="width:1px; background:#ddd; margin:0 4px;"></div>
          <button class="btn-icon" id="align-left" title="Align Left"><i class="fa-solid fa-align-left"></i></button>
          <button class="btn-icon" id="align-center" title="Align Center"><i class="fa-solid fa-align-center"></i></button>
          <button class="btn-icon" id="align-right" title="Align Right"><i class="fa-solid fa-align-right"></i></button>
        </div>
      </div>
    </div>

    <div class="tool-group" style="margin-left:auto; border:none;">
      <button class="btn-icon" id="zoom-out"><i class="fa-solid fa-minus"></i></button>
      <div style="font-size:12px; font-weight:600; width:45px; text-align:center;" id="zoom-level">100%</div>
      <button class="btn-icon" id="zoom-in"><i class="fa-solid fa-plus"></i></button>
    </div>
  </div>

  <div id="workspace">
    <div id="canvas-container">
      <canvas id="pdf-layer"></canvas>
      <canvas id="ui-layer"></canvas>
      <textarea id="inline-editor"></textarea>
    </div>
  </div>

  <div id="upload-overlay">
    <i class="fa-solid fa-cloud-arrow-up fa-5x" style="color:var(--accent-dark);"></i>
    <h1 style="color:#0f172a;">Load your Document</h1>
    <button class="big-upload-btn" onclick="document.getElementById('file-input').click()">
      Browse PDF Files
    </button>
    <p style="color:#64748b; font-size:14px;">Secure Processing â€¢ Bank Grade Logic</p>
  </div>

  <input type="file" id="file-input" accept="application/pdf" style="display:none" />
  <input type="file" id="img-input" accept="image/png, image/jpeg" style="display:none" />

  <script>
    // --- SETUP WORKER ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // --- STATE ---
    const App = {
      pdfDoc: null,
      pdfLibDoc: null,
      pdfBytes: null,
      pageNum: 1,
      scale: 1.25,
      tool: 'select',
      objects: [],     // All text/images/whiteouts
      selectedId: null,
      isEditing: false,
      history: [],     // For Undo/Redo
      historyStep: -1
    };

    // --- DOM REFERENCES ---
    const canvasContainer = document.getElementById('canvas-container');
    const pdfCanvas = document.getElementById('pdf-layer');
    const uiCanvas = document.getElementById('ui-layer');
    const pdfCtx = pdfCanvas.getContext('2d');
    const uiCtx = uiCanvas.getContext('2d');
    const editor = document.getElementById('inline-editor');

    // Controls
    const fontSel = document.getElementById('font-family');
    const sizeInp = document.getElementById('font-size');
    const colorInp = document.getElementById('font-color');
    const boldBtn = document.getElementById('btn-bold');

    // --- INITIALIZATION ---
    window.addEventListener('DOMContentLoaded', () => {
      // 1. File Upload Handlers
      document.getElementById('file-input').addEventListener('change', (e) => loadPDF(e.target.files[0]));
      document.getElementById('btn-open').addEventListener('click', () => document.getElementById('file-input').click());
      document.getElementById('btn-save').addEventListener('click', savePDF);

      // 2. Toolbar Tools
      document.querySelectorAll('[data-tool]').forEach(btn => {
        btn.addEventListener('click', () => setTool(btn.dataset.tool));
      });
      // Image Tool Specific
      document.getElementById('tool-img-trigger').addEventListener('click', () => {
        setTool('image');
        document.getElementById('img-input').click();
      });
      document.getElementById('img-input').addEventListener('change', (e) => loadImage(e.target.files[0]));

      // 3. Formatting
      [fontSel, sizeInp, colorInp].forEach(el => el.addEventListener('input', updateSelectedProp));
      boldBtn.addEventListener('click', () => {
        boldBtn.classList.toggle('active');
        updateSelectedProp();
      });
      // Alignments
      ['left','center','right'].forEach(align => {
        document.getElementById('align-'+align).addEventListener('click', () => {
          if(App.selectedId) {
            const obj = App.objects.find(o => o.id === App.selectedId);
            if(obj && obj.type === 'text') {
              obj.align = align;
              saveHistory(); renderUI();
            }
          }
        });
      });

      // 4. Undo/Redo
      document.getElementById('btn-undo').addEventListener('click', performUndo);
      document.getElementById('btn-redo').addEventListener('click', performRedo);
      document.getElementById('btn-delete').addEventListener('click', deleteSelected);

      // 5. Canvas Interactions
      uiCanvas.addEventListener('mousedown', onMouseDown);
      uiCanvas.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      uiCanvas.addEventListener('dblclick', onDoubleClick);

      // 6. Editor Input
      editor.addEventListener('blur', commitEditorChanges);
      
      // 7. Zoom
      document.getElementById('zoom-in').onclick = () => { App.scale += 0.1; renderPDF(); };
      document.getElementById('zoom-out').onclick = () => { App.scale = Math.max(0.5, App.scale - 0.1); renderPDF(); };
    });

    // --- CORE LOGIC ---

    async function loadPDF(file) {
      if (!file) return;
      try {
        // FIX: Clone the buffer so both libraries get a fresh copy
        const rawBuffer = await file.arrayBuffer();
        App.pdfBytes = rawBuffer.slice(0); // Clone for PDF-Lib
        
        App.pdfDoc = await pdfjsLib.getDocument({ data: rawBuffer }).promise;
        App.pdfLibDoc = await PDFLib.PDFDocument.load(App.pdfBytes);
        
        // Reset State
        App.objects = [];
        App.history = [];
        App.historyStep = -1;
        App.selectedId = null;
        
        document.getElementById('upload-overlay').classList.add('hidden');
        document.getElementById('btn-save').disabled = false;
        
        renderPDF();
        saveHistory(); // Initial state
      } catch (err) {
        alert("Upload Error: " + err.message);
        console.error(err);
      }
    }

    async function renderPDF() {
      if (!App.pdfDoc) return;
      const page = await App.pdfDoc.getPage(App.pageNum);
      const viewport = page.getViewport({ scale: App.scale });

      // Resize
      canvasContainer.style.width = viewport.width + 'px';
      canvasContainer.style.height = viewport.height + 'px';
      [pdfCanvas, uiCanvas].forEach(c => { c.width = viewport.width; c.height = viewport.height; });

      // Render
      await page.render({ canvasContext: pdfCtx, viewport }).promise;
      
      document.getElementById('zoom-level').textContent = Math.round(App.scale * 100) + '%';
      renderUI();
    }

    // --- UI RENDERING (The "Adobe" Look) ---
    function renderUI() {
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);

      App.objects.forEach(obj => {
        // If we are text-editing, hide the canvas text so we don't see double
        if (App.isEditing && App.selectedId === obj.id) return;

        const x = obj.x * App.scale;
        const y = obj.y * App.scale;
        const w = obj.w * App.scale;
        const h = obj.h * App.scale;

        if (obj.type === 'whiteout') {
          uiCtx.fillStyle = '#ffffff';
          uiCtx.fillRect(x, y, w, h);
        } else if (obj.type === 'image') {
          uiCtx.drawImage(obj.img, x, y, w, h);
        } else if (obj.type === 'text') {
          uiCtx.save();
          // Font Logic
          let family = 'Helvetica';
          if (obj.font === 'BankCourier') family = '"Courier Prime", monospace';
          if (obj.font === 'Times') family = '"Times New Roman", serif';
          
          uiCtx.font = `${obj.bold ? 'bold ' : ''}${obj.size * App.scale}px ${family}`;
          uiCtx.fillStyle = obj.color;
          uiCtx.textBaseline = 'top';
          
          // Alignment Logic
          let drawX = x;
          const textW = uiCtx.measureText(obj.text).width;
          if(obj.align === 'center') drawX = x + (w - textW)/2;
          if(obj.align === 'right') drawX = x + (w - textW);

          uiCtx.fillText(obj.text, drawX, y);
          uiCtx.restore();
        }
      });

      // Draw Selection Box
      if (App.selectedId && !App.isEditing) {
        const obj = App.objects.find(o => o.id === App.selectedId);
        if (obj) {
          const x = obj.x * App.scale, y = obj.y * App.scale;
          const w = obj.w * App.scale, h = obj.h * App.scale;
          
          uiCtx.strokeStyle = '#0066cc';
          uiCtx.lineWidth = 1.5;
          uiCtx.setLineDash([4, 2]);
          uiCtx.strokeRect(x, y, w, h);
          uiCtx.setLineDash([]);
          
          // Handles
          uiCtx.fillStyle = '#cceeff';
          uiCtx.strokeStyle = '#0066cc';
          const handles = [[x,y], [x+w,y], [x,y+h], [x+w,y+h]];
          handles.forEach(([hx,hy]) => {
            uiCtx.fillRect(hx-4, hy-4, 8, 8);
            uiCtx.strokeRect(hx-4, hy-4, 8, 8);
          });
        }
      }
    }

    // --- INTERACTION ---
    let dragStart = null;

    function getMousePos(e) {
      const rect = uiCanvas.getBoundingClientRect();
      return { 
        x: (e.clientX - rect.left) / App.scale, 
        y: (e.clientY - rect.top) / App.scale 
      };
    }

    function onMouseDown(e) {
      const {x, y} = getMousePos(e);

      if (App.tool === 'select') {
        // Hit detection
        const clicked = App.objects.slice().reverse().find(o => 
          x >= o.x && x <= o.x + o.w && y >= o.y && y <= o.y + o.h
        );
        if (clicked) {
          App.selectedId = clicked.id;
          dragStart = { x, y, initialX: clicked.x, initialY: clicked.y };
          syncPropPanel(clicked);
        } else {
          App.selectedId = null;
        }
      } else if (App.tool === 'text') {
        createSmartText(x, y);
      } else if (App.tool === 'whiteout') {
        dragStart = { x, y, isNew: true };
      }
      renderUI();
    }

    function onMouseMove(e) {
      const {x, y} = getMousePos(e);
      
      if (dragStart) {
        if (App.tool === 'select' && App.selectedId) {
          const obj = App.objects.find(o => o.id === App.selectedId);
          obj.x = dragStart.initialX + (x - dragStart.x);
          obj.y = dragStart.initialY + (y - dragStart.y);
          
          // Move linked mask if exists
          if(obj.maskId) {
             const mask = App.objects.find(m => m.id === obj.maskId);
             if(mask) { mask.x = obj.x; mask.y = obj.y; }
          }
        } else if (dragStart.isNew) {
          // Visual feedback for whiteout creation would go here
        }
        renderUI();
      }
    }

    function onMouseUp(e) {
      const {x, y} = getMousePos(e);
      
      if (App.tool === 'whiteout' && dragStart && dragStart.isNew) {
        const w = Math.abs(x - dragStart.x);
        const h = Math.abs(y - dragStart.y);
        const finalX = Math.min(x, dragStart.x);
        const finalY = Math.min(y, dragStart.y);
        if(w > 5 && h > 5) {
          App.objects.push({
            id: Date.now(), type: 'whiteout', x: finalX, y: finalY, w, h
          });
          saveHistory();
        }
      } else if (dragStart) {
        saveHistory(); // End of drag
      }
      dragStart = null;
      renderUI();
    }

    function onDoubleClick(e) {
      const {x, y} = getMousePos(e);
      const clicked = App.objects.find(o => o.type === 'text' && 
          x >= o.x && x <= o.x + o.w && y >= o.y && y <= o.y + o.h
      );
      if (clicked) {
        App.selectedId = clicked.id;
        startEditing(clicked);
      }
    }

    // --- SMART TEXT & ADOBE LOGIC ---

    function createSmartText(x, y) {
      const id = Date.now();
      const maskId = id + 1;
      
      // 1. Create Whiteout (Mask) Behind
      App.objects.push({
        id: maskId, type: 'whiteout', x, y, w: 120, h: 24
      });
      
      // 2. Create Text
      const textObj = {
        id, type: 'text', text: '',
        x, y, w: 120, h: 24,
        font: fontSel.value,
        size: parseInt(sizeInp.value),
        color: colorInp.value,
        bold: boldBtn.classList.contains('active'),
        align: 'left',
        maskId: maskId
      };
      
      App.objects.push(textObj);
      App.selectedId = id;
      setTool('select');
      saveHistory();
      startEditing(textObj);
    }

    function startEditing(obj) {
      App.isEditing = true;
      
      const pxX = obj.x * App.scale;
      const pxY = obj.y * App.scale;
      
      editor.style.display = 'block';
      editor.style.left = pxX + 'px';
      editor.style.top = pxY + 'px';
      editor.style.width = (obj.w * App.scale) + 'px';
      editor.style.height = (obj.h * App.scale * 1.2) + 'px';
      
      // CSS Styling matches Canvas
      let family = 'Helvetica';
      if (obj.font === 'BankCourier') family = '"Courier Prime", monospace';
      if (obj.font === 'Times') family = '"Times New Roman", serif';
      
      editor.style.fontFamily = family;
      editor.style.fontSize = (obj.size * App.scale) + 'px';
      editor.style.fontWeight = obj.bold ? 'bold' : 'normal';
      editor.style.color = obj.color;
      editor.style.textAlign = obj.align;
      
      editor.value = obj.text;
      editor.focus();
      renderUI();
    }

    function commitEditorChanges() {
      if (!App.isEditing) return;
      const obj = App.objects.find(o => o.id === App.selectedId);
      if (obj) {
        obj.text = editor.value;
        
        // Auto-Resize Width based on text length
        uiCtx.font = `${obj.bold?'bold ':''}${obj.size}px ${obj.font==='BankCourier'?'Courier Prime':'Helvetica'}`;
        const textW = uiCtx.measureText(obj.text).width + 20;
        obj.w = Math.max(textW, 50);
        
        // Sync Mask
        if(obj.maskId) {
          const mask = App.objects.find(m => m.id === obj.maskId);
          if(mask) { mask.w = obj.w; mask.h = obj.h; }
        }
      }
      App.isEditing = false;
      editor.style.display = 'none';
      saveHistory();
      renderUI();
    }

    // --- HELPER FUNCTIONS ---
    function setTool(t) {
      if(App.isEditing) commitEditorChanges();
      App.tool = t;
      App.selectedId = null;
      document.querySelectorAll('.btn-large').forEach(b => b.classList.toggle('active', b.dataset.tool === t));
      uiCanvas.style.cursor = t === 'select' ? 'default' : 'crosshair';
      renderUI();
    }

    function syncPropPanel(obj) {
      if(obj.type !== 'text') return;
      fontSel.value = obj.font;
      sizeInp.value = obj.size;
      colorInp.value = obj.color;
      if(obj.bold) boldBtn.classList.add('active'); else boldBtn.classList.remove('active');
    }

    function updateSelectedProp() {
      if(!App.selectedId) return;
      const obj = App.objects.find(o => o.id === App.selectedId);
      if(obj && obj.type === 'text') {
        obj.font = fontSel.value;
        obj.size = parseInt(sizeInp.value);
        obj.color = colorInp.value;
        obj.bold = boldBtn.classList.contains('active');
        saveHistory(); renderUI();
      }
    }

    function loadImage(file) {
      if(!file) return;
      const img = new Image();
      img.onload = () => {
        App.objects.push({
          id: Date.now(), type: 'image', img, x: 50, y: 50, w: 200, h: 200 * (img.height/img.width)
        });
        saveHistory(); renderUI();
      };
      img.src = URL.createObjectURL(file);
    }

    function deleteSelected() {
      if(!App.selectedId) return;
      const obj = App.objects.find(o => o.id === App.selectedId);
      // Remove mask if attached
      if(obj && obj.maskId) {
         App.objects = App.objects.filter(x => x.id !== obj.maskId);
      }
      App.objects = App.objects.filter(x => x.id !== App.selectedId);
      App.selectedId = null;
      saveHistory(); renderUI();
    }

    // --- UNDO / REDO ---
    function saveHistory() {
      // Remove future states if we were back in time
      if(App.historyStep < App.history.length - 1) {
        App.history = App.history.slice(0, App.historyStep + 1);
      }
      // Shallow copy is enough for this simple structure
      // But we need to avoid circular refs if any (imgs are refs). 
      // Simplified: We just store the array structure.
      const snapshot = App.objects.map(o => ({...o})); 
      App.history.push(snapshot);
      App.historyStep++;
    }

    function performUndo() {
      if(App.historyStep > 0) {
        App.historyStep--;
        restoreSnapshot(App.history[App.historyStep]);
      }
    }
    
    function performRedo() {
      if(App.historyStep < App.history.length - 1) {
        App.historyStep++;
        restoreSnapshot(App.history[App.historyStep]);
      }
    }

    function restoreSnapshot(snap) {
      // Restore logic needs to handle Image objects which can't be JSON'd easily
      // Since we kept refs in memory, it's fine for this session.
      App.objects = snap.map(o => ({...o}));
      renderUI();
    }

    // --- SAVING PDF ---
    async function savePDF() {
      if(!App.pdfLibDoc) return;
      
      const doc = App.pdfLibDoc;
      const pages = doc.getPages();
      const page = pages[App.pageNum - 1];
      const { height } = page.getSize();
      
      // Embed Fonts
      const helv = await doc.embedFont(PDFLib.StandardFonts.Helvetica);
      const helvBold = await doc.embedFont(PDFLib.StandardFonts.HelveticaBold);
      const cour = await doc.embedFont(PDFLib.StandardFonts.Courier);
      const courBold = await doc.embedFont(PDFLib.StandardFonts.CourierBold);
      const times = await doc.embedFont(PDFLib.StandardFonts.TimesRoman);
      
      for(const o of App.objects) {
        const y = height - o.y - o.h;
        
        if(o.type === 'whiteout') {
           page.drawRectangle({ x: o.x, y, width: o.w, height: o.h, color: PDFLib.rgb(1,1,1) });
        }
        else if(o.type === 'text') {
           let font = helv;
           if(o.font === 'BankCourier') font = o.bold ? courBold : cour;
           if(o.font === 'Times') font = times;
           if(o.font === 'Helvetica' && o.bold) font = helvBold;

           const rgb = hexToRgb(o.color);
           const color = PDFLib.rgb(rgb.r/255, rgb.g/255, rgb.b/255);
           
           // Calculate Align Offset
           const textW = font.widthOfTextAtSize(o.text, o.size);
           let tx = o.x;
           if(o.align === 'center') tx = o.x + (o.w - textW)/2;
           if(o.align === 'right') tx = o.x + (o.w - textW);

           page.drawText(o.text, {
             x: tx, y: height - o.y - (o.size*0.8), // visual baseline adjustment
             size: o.size,
             font: font,
             color: color
           });
        }
      }
      
      const pdfBytes = await doc.save();
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'edited_document.pdf';
      link.click();
    }

    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1,3), 16);
      const g = parseInt(hex.slice(3,5), 16);
      const b = parseInt(hex.slice(5,7), 16);
      return {r,g,b};
    }
  </script>
</body>
</html>
